MODULE
;set uname before checking pass!
;uname can be used in main app
BYTE ARRAY UNAME(10)
BYTE ARRAY UATTR(32)


BYTE FUNC UCase(BYTE ch)
  IF ch > 96 THEN
    ch==-32
  FI
RETURN (ch)

; Needs to be in UTIL as requires
; both TIME and NETWORK...
;
; 2025-10-24: swiched from RXBUFF to
;             NSB.. may cause issues
BYTE FUNC NGetB()
  nv = 0
  nc = 0
  WHILE nv = 0
  DO
    NStatus()
    IF BYTESWAITING > 0 THEN
      NRead(NSB, 1)
      NGetStatus()
      IF ERRNO <> 1 THEN
        PrintF("Read err: %B%E",ERRNO)
        IS_CONN = 0
        RETURN(nc)
      FI
      nc = NSB(0)
;     TRIP = 0
;     PACTL = PACTL % 1
      nv = 1
    ELSE
      IF TSessExp() = 1 THEN
        RETURN(nc)
      FI
    FI
  OD
RETURN (nc)


PROC NPrintFile(BYTE ARRAY file)
  BYTE l=[0]
  c = 0
  l = 0
  i = 0

  NPutC(125)

  Close(FIOCB)
  Open(FIOCB,file,4,0)

  DO
    RXBUFF(i) = GetD(FIOCB)

    IF EOF(FIOCB) <> 0 THEN
      NWrite(RXBUFF, i)
      EXIT
    FI

    IF RXBUFF(i) = 155 THEN
      l==+1
    FI

    i==+1

    IF i > 39 OR l > 21 THEN
      NWrite(RXBUFF, i)
      i = 0

      IF l > 21 THEN
        IF c <> 'C THEN
          NWriteS("[MORE, Continuous, Exit]")
          c = NGetB()
          c = UCase(c)
          FOR v = 0 TO 23
          DO
            NSB(v) = 126
          OD
          NWrite(NSB,24)
          IF c = 'X THEN
            NPutC(155)
            EXIT
          FI
        FI
        l = 0
      ELSE
        NStatus()

        IF BYTESWAITING > 0 THEN
          NRead(NSB, 1)
;          TRIP = 0
;          PACTL = PACTL % 1
          IF NSB(0) = 3 THEN
            EXIT
          FI
        FI

      FI
    FI
  OD

  Close(FIOCB)

RETURN


CARD FUNC ReadInp()
  CARD readLen=[0]

; IF TRIP = 0 THEN
;   RETURN (0)
; FI

  NStatus()

  IF BYTESWAITING = 0 THEN
    RETURN (0)
  FI

  IF BYTESWAITING > 38 THEN
    BYTESWAITING = 38
  FI
  readLen = BYTESWAITING
  NRead(NSB,readLen)

; TRIP = 0
; PACTL = PACTL % 1

RETURN (readLen)

;returns idx of last char
BYTE FUNC GetInp()
  BYTE checkC=[0]
  CARD readLen=[0]

  readLen = 0
  c = 0
  checkC = 0

  FOR i = 0 TO 39
  DO
    RXBUFF(i) = 32
    NSB(i) = 32
  OD

  IF IS_CONN = 0 THEN
    RETURN(0)
  FI

  WHILE IS_CONN = 1
  DO
    readlen = ReadInp()

    IF readLen > 0 THEN

      readLen==-1
      FOR i = 0 TO readLen
      DO

        IF NSB(i) = 155 THEN
          NPutC(155)
          RETURN (c)
        ELSEIF NSB(i) = 126 AND c > 0 THEN
          NPutC(126)
          RXBUFF(c) = 32
          c==-1
        ELSEIF c < 38 THEN

          ;allow inverse text when
          ;not in gfx mode if flagged
          checkC = NSB(i)
          IF ALLOW_INVERTED=1 AND checkC >= 128 THEN checkC ==- 128 FI

          IF GFXMODE = 0 AND (checkC < 32 OR checkC > 122) THEN
            ; IGNORE
          ELSE
            RXBUFF(c) = NSB(i)
            IF IMASK > 0 THEN
              NSB(i) = IMASK
            FI
            NPutC(NSB(i))
            c==+1
          FI
        FI
      OD
    ELSE
      IF TSessExp() = 1 THEN
        RETURN(c)
      FI
    FI
  OD

RETURN(c)

