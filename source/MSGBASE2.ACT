MODULE

;BYTE ARRAY lOffset(25)
;CARD ARRAY lSect(25)

BYTE maxLine=[0]

;converts two byte ATASCII to
;byte number
BYTE FUNC atob(BYTE n1,n2)
  BYTE val=[0]
  val=0

  IF n1 = 32 AND n2 = 32 THEN
    RETURN(0)
  FI

  n1==-48

  IF n2 <> 32 AND n2 <> 155 THEN
    n1==*10
    n2==-48
    n1==+n2
  FI

  val=n1
RETURN(val)


PROC EditLine(BYTE l)
  BYTE viewOffset=[0]
  CARD viewSect=[0]

  IF maxLine = 0 THEN
    NWriteSE("No message yet to edit!")
    RETURN
  FI

  ;PrintF("EDIT: %B max=%B%E",l,maxLine)


  l==-1 ;conv to 0 based idx

  IF l >= maxLine THEN
    l = maxLine - 1
  FI

;  PrintF("EDIT: %B max=%B%E",l,maXLine)

  viewSect = lSect(l)
  IF lOffset(l) = 0 THEN
    viewSect==-1
  FI
  viewOffset = lOffset(l) - 1

;  PrintF("VPOINT(%B): %U %B%E",l,viewSect,viewOffset)
  Point(5,viewSect,viewOffset)

  NPutC('-)
  FOR i = 0 to 37
  DO
    RXBUFF(i) = GetD(5)
  OD
  NWriteS(RXBUFF)
  NPutC('+)

  GetInp()

;  PrintF("WPOINT(%B): %U %B%E",l,lSect(l),lOffset(l))
  Point(5,lSect(l),lOffset(l))

  FOR i = 0 TO 37
  DO
    PutD(5,RXBUFF(i))
  OD

  PutD(5,155)

;  PrintF("RETURN TO: %B s=%U o=%B%E",maxLine,lSect(maxLine),lOffset(maxLine))

  Point(5,lSect(maxLine),lOffset(maxLine))
;  PrintF("EDITRETURN s=%U o=%B max=%B%E",lSect(maxLine),lOffset(maxLine),maxLine)

RETURN


PROC ListMsg(BYTE t)
  BYTE l=[0],idx=[0],k=[0]
  BYTE ARRAY ls(4)

;  PrintF("LIST MAX=%B TYPE=%C%E",maxLine,t)

  IF maxLine = 0 THEN
    NWriteSE("You haven't written anything yet!")
    RETURN
  FI

  Point(5,lSect(0),lOffset(0))

  l = 1
  idx = 0
  WHILE l <= maxLine
  DO
    IF EOF(5) <> 0 THEN
      Printf("ERROR EOF! l=%B max=%B%E",l,maxLine)
      EXIT
    FI

    k = GetD(5)

    IF idx > 39 THEN
      PrintF("WARN:idx=%B ",idx)
      k=155
      RXBUFF(38)=155
      i=38
    FI

    IF k <> 155 THEN
      RXBUFF(idx) = k
      idx==+1

    ;IF k = 155 THEN
    ELSE
      IF t = 'n THEN
        StrB(l,ls)
        NWriteS(ls)
        NPutC(':)
        IF idx > 37 THEN
          idx==-2
        FI
     ;   idx==-2 ;give space for nums
     ;   RXBUFF(idx-1)=155

      FI
      NWrite(RXBUFF,idx)
      NPutC(155)
      idx = 0
      l==+1
;      PrintF("l=%B max=%B%E",l,maxLine)
    FI
  OD

;  PrintF("RETURN TO: %B s=%U o=%B ",maxLine,lSect(maxLine),lOffset(maxLine))

  Point(5,lSect(maxLine),lOffset(maxLine))
;  PrintE("SUCCESS")
RETURN



PROC DeleteLines(BYTE l)
  BYTE ARRAY sl(5)

  IF maxLine = 0 THEN
    NWriteSE("No lines yet to delete!")
    RETURN
  FI

  PrintF("DELETE1 l=%B%E",l)

  IF l > 0 THEN

    StrB(l,sl)

    l==-1
    PrintF("DELETE2 l=%B%E",l)

    IF l > maxLine THEN
      l = maxLine
      StrB((l-1),sl)
    FI
    PrintF("DELETE3 l=%B%E",l)



    NWriteS(">>Delete line ")
    NWriteS(sl)
    NWriteS(" to end of msg [n]?")

    c = NGetB()
    NPutC(155)
    IF c <> 'y THEN
      RETURN
    FI

    NWriteSE(">>Line(s) deleted!")
    maxLine = l

  ELSE
    NWriteSE(">>Last line deleted!")
    maxLine==-1

  FI

  Point(5,lSect(maxLine),lOffset(maxLine))
RETURN


BYTE FUNC HEditCmd()
  BYTE status=[0]
  status = 0

  IF RXBUFF(1) = 's THEN
    IF maxLine = 0 THEN
      NWriteSE("Not saving empty message.")
      status = 1
    ELSE
      status = 2
      NWriteSE(">>Saving post...")
    FI
  ELSEIF RXBUFF(1) = 'a THEN
    IF maxLine = 0 THEN
      status = 1
    ELSE
      NWriteS("Abort current message [n]?")
      c = NGetB()
      NPutC(155)
      IF c = 'y THEN
        status = 1
      FI
    FI

  ELSEIF RXBUFF(1) = 'b THEN
    NWriteS("Clear msg and restart [n]?")
    c = NGetB()
    NPutC(155)
    IF c = 'y THEN
      NWriteSE(">>Message cleared!")
      Point(5,lSect(0),lOffset(0))
      maxLine = 0
    FI

  ELSEIF RXBUFF(1) = 'd THEN
    c = atob(RXBUFF(2),RXBUFF(3))
    DeleteLines(c)

  ELSEIF RXBUFF(1) = 'g THEN
    GFXMODE = GFXMODE ! 1
    IF GFXMODE = 1 THEN
      NWriteSE("Graphics mode on")
    ELSE
      NWriteSE("Graphics mode off")
    FI

  ELSEIF RXBUFF(1) = 'l OR RXBUFF(1) = 'n THEN
;    PrintE("BEFORE LIST")
    ListMsg(RXBUFF(1))
;    PrintE("AFTER LIST")

  ELSEIF RXBUFF(1) = 'e THEN
    c = atob(RXBUFF(2),RXBUFF(3))
    EditLine(c)

  ELSEIF RXBUFF(1) = '? THEN
    NWriteSE("EDITOR QUICK HELP")
    NWriteSE("/a  - Abort post")
    NWriteSE("/b  - Clear current msg and begin again")
    NWriteSE("/d  - Delete last line")
    NWriteSE("/d# - Delete line # to end")
    NWriteSE("/e# - Edit line #")
    NWriteSE("/g  - Toggle ATASCII gfx mode")
    NWriteSE("/l  - List message")
    NWriteSE("/n  - List msg with line numbers")
    NWriteSE("/s  - Save post")
    NWriteSE("EDITOR QUICK HELP")

  ELSE
    NWriteSE("Type /? for help")
  FI

RETURN(status)


PROC PostMsg(BYTE parentId)
  BYTE nMsg=[0],tOffset=[0],sOffset=[0]
  BYTE maxI=[0],k=[0],status=[0],skip=[0]
  CARD tSect=[0],sSect=[0]
  BYTE ARRAY nl(2)
  skip=0
  status=0
  maxI=0
  sOffset=0
  sSect=0

  nMsg = HIMSGID + 1
  IF nMsg > 49 THEN
    nMsg = 0
    MBROLL = 1
  FI

  IF parentId > 49 THEN
    parentId = 255
  FI

  Close(5)
  Open(5,MTEMPNAME,12,0)

  Note(5,@sSect,@sOffset)

  PrintD(5, "DATE:")
  NGetDT()
  FOR i = 0 TO 16
  DO
    PutD(5, RXBUFF(i))
  OD
  PutD(5, 155)

  PrintD(5, "FROM: ")

  FOR i = 0 TO 9
  DO
    PutD(5, UNAME(i))
  OD
  PutD(5,155)

  NPutC(125)

  SCopy(RXBUFF, "  TO: ")
  PrintD(5, RXBUFF)

  IF parentId = 255 THEN

    NWriteS(RXBUFF)

    maxI = GetInp()

    IF RXBUFF(0) = 32 THEN
      PrintDE(5, "ALL")
      maxI = 2
    ELSE
      IF maxI > 29 THEN maxI = 29 FI
      FOR i = 0 TO maxI
      DO
        c = UCase(RXBUFF(i))
        PutD(5, c)
      OD
    FI
  ELSE
    ; auto fill to field on replies

    maxI = 0
    i = 30
    WHILE i > 0
    DO
      i==-1
      Put(PREVFROM(i))
      IF PREVFROM(i) <> 32 THEN
        maxI = i+1
        PrintF("%ETO MAXI=%B%E",maxI)
        EXIT
      FI
    OD
    Put(155)
    Print("PREV FROM: ")
    FOR i = 0 TO maxI
    DO
      Put(PREVFROM(i))
      PutD(5,PREVFROM(i))
    OD
  FI

  PutD(5, 155)

  SCopy(RXBUFF, "SUBJ: ")
  PrintD(5,RXBUFF)

  IF parentId <> 255 THEN
    NWriteS("Use prev subject [y]? ")
    maxI = NGetB()
    NPutC(155) ;might be wrong place

  FI

  IF parentId = 255 OR (maxI = 'n OR maxI = 'N) THEN

    NWriteS(RXBUFF)

    maxI = GetInp()

    IF maxI > 29 THEN maxI = 29 FI

    FOR i = 0 TO maxI
    DO
      PutD(5, RXBUFF(i))
    OD
  ELSE

    PrintF("%ESUBJ:")
    maxI = 0
    i = 30
    WHILE i > 0
    DO
      i==-1
      Put(PREVSUBJ(i))
      IF PREVSUBJ(i) <> 32 THEN
        maxI = i+1 ;seems wrong
        PrintF("%ESUBJ MAX: %B%E",maxI)
        EXIT
      FI
    OD
    Put(155)

    IF PREVSUBJ(0)<>'R OR PREVSUBJ(1)<>'E OR PREVSUBJ(2)<>': THEN

      maxI==+3
      IF maxI > 29 THEN maxI = 29 FI

      RXBUFF(0)='R
      RXBUFF(1)='E
      RXBUFF(2)=':

      FOR i = 0 TO maxI
      DO
        RXBUFF(i+3)=PREVSUBJ(i)
      OD
      FOR i = 0 TO maxI
      DO
        PREVSUBJ(i)=RXBUFF(i)
      OD
    ELSE
      PrintE("PREV SUBJ MATCHES RE:??")

    FI

    FOR i = 0 TO maxI
    DO
      Put(PREVSUBJ(i))
      PutD(5, PREVSUBJ(i))
    OD
  FI

  NPutC(155)

  PutD(5,155)
  PutD(5,155)
  SCopy(RXBUFF, "----+----")
  FOR i = 0 TO 2
  DO
    NWriteS(RXBUFF)
  OD
  NWriteSE("----+---")

  maxLine = 0

  Note(5,@tSect,@tOffset)
  lSect(maxLine) = tSect
  lOffset(maxLine) = tOffset

  WHILE status = 0 AND IS_CONN = 1
  DO

    skip = 0
;    PrintF("j=%B s=%U o=%B%E",j,lSect(j),lOffset(j))
    maxI = GetInp()

    FOR i = 0 TO 37; maxI
    DO
      c = RXBUFF(i)
      IF i = 0 AND c = '/ THEN
        skip = 1
        status = HEditCmd()

        ;not trusting nested EXIT
        i=37
      ELSEIF maxLine <= 20 THEN
        PutD(5, c)
      FI
    OD

    IF skip = 0 AND status = 0 AND maxLine > 19 THEN
      NWriteSE("Max msg lines reached!")
      skip = 1
    FI
    IF skip = 0 THEN
      PutD(5, 155)

      IF maxLine >= 14 THEN
        IF (19-maxLine) = 0 THEN
          NWriteSE("Max msg lines reached!")
        ELSE
          StrB((19-maxLine),nl)
          NWriteS("WARN> ")
          NWriteS(nl)
          NWriteSE(" lines left.")
        FI
      FI
      maxLine==+1

      Note(5,@tSect,@tOffset)
      lSect(maxLine) = tSect
      lOffset(maxLine) = tOffset

    FI

  OD

  IF status = 2 THEN

    SetMsgCoords(nMsg)

    Close(6)
    Open(6,MBFNAME,12,0)
    Point(6,MS,MO)

    Point(5,sSect,sOffset)

    ; mark parent id as first byte
    PutD(6,parentId)

    ;copy headers to msg base
    maxI = 0

    DO
      c = GetD(5)
      PutD(6,c)
      IF c = 155 THEN
        maxI==+1
        IF maxI = 4 THEN
          EXIT
        FI
      FI
    OD

    PutD(6,155)

    ; copy msg body to msg base
    ; removing any trailing spaces

    ;don't save final input line
    maxLine==-1

    FOR i = 0 TO maxLine
    DO
      Point(5,lSect(i),lOffset(i))
      maxI = 0
      FOR v = 0 TO 37
      DO
        c = GetD(5)
        RXBUFF(v) = c

        IF c <> 32 THEN
          maxI = v
        FI
      OD

      FOR v = 0 TO maxI
      DO
        PutD(6,RXBUFF(v))
      OD
      PutD(6,155)
    OD
    PutD(6,158)

    Close(6)

    HIMSGID = nMsg
    NWriteSE("Message posted")

    Open(6,MHFNAME,8,0)
    PrintBDE(6,HIMSGID)
    PrintBDE(6,MBROLL)
    Close(6)

    UATTR(7)==+1
    IF UATTR(7) = 0 THEN
      UATTR(6)==+1
    FI
    PrintE("New Msg")
  ELSE
    NWriteSE("Message canceled")
  FI

  Close(5)
  GFXMODE = 0

RETURN


; Updates msgid (n) based on
; dir. If at end of base, prompt
; to post a msg. If user doesn't
; return 'magic' OOB 200 to signal
; to exit msg base
;
BYTE FUNC CheckIdOOB(BYTE n,dir)
  BYTE dId=[0]

  ;TODO:this only works when the base
  ;     has rolled!

  dId = GetDispId(n)
  IF (dId = 50 AND dir = 1) OR (dId = 1 AND dir = 0) THEN
    NPutC(155)
    NWriteSE("End of messages")
    NPutC(155)
    NWriteS("Post a new message? [n]")
    c = NGetB()
    IF c = 'y OR c = 'Y THEN
      PostMsg()
      RETURN(n)
    ELSE
      RETURN(200)
    FI
  ELSE
    IF dir = 1 THEN
      n==+1
    ELSE
      n==-1
    FI
  FI
RETURN(n)


PROC ReadMsgs()

  BYTE n=[0],rDraw=[1],dId=[0],dir=[0]

  rDraw=1
  dir=0
  dId=0

  PrintF("U=%B Hi=%B%E",UATTR(5),HIMSGID)

  n=UATTR(5)
  IF n <> HIMSGID THEN
    dir=1
  FI

  NPutC(125)

  WHILE IS_CONN = 1
  DO
    IF rDraw = 1 THEN
      ViewMsg(n)

      IF dir = 1 THEN
        NWriteS("MSGS+> ")
      ELSE
        NWriteS("MSGS-> ")
      FI
    FI
    rDraw = 1
    c = NGetB()
    c = UCase(c)

    IF c = 'N OR c = 32 OR c = 123 THEN
      n = CheckIdOOB(n,dir)

    ELSEIF c = '> THEN
      n = CheckIdOOB(n,1)

    ELSEIF c = '< THEN
      n = CheckIdOOB(n,0)

    ELSEIF c = 'J THEN
      NPutC(155)
      NWriteS("TO MSG ID: ")
      GetInp()

      n = atob(RXBUFF(0),RXBUFF(1))

      IF n > 50 THEN
        NWriteSE("ERROR: ID must be <= 50!")
        TSleep(20)
        n = HIMSGID
      ELSE
        n = GetRealId(n)
      FI

    ELSEIF c = 'R THEN
      PostMsg(n)
    ELSEIF c = 'P THEN
      PostMsg(255) ;no parent
    ELSEIF c = 'T THEN
      n = LASTPID
    ELSEIF c = 'X THEN
      EXIT
    ELSEIF c = 'A THEN
      ;default redraw
    ELSEIF c = 'F or c = '+ THEN
      dir = 1
      NPutC(155)
      NWriteSE("FORWARD READ")
    ELSEIF c = 'B or c = '- THEN
      dir = 0
      NPutC(155)
      NWriteSE("BACKWARD READ")
    ELSEIF c = '? THEN
      NPrintFile("D1:MSGHELP.ATA")
      NGetB()
    ELSE
      rDraw = 0
    FI

    ;keep id in bounds
    IF n = 50 THEN
      n = 0
    ELSEIF n = 255 THEN
      ;when viewid=0
      n = 49
    ELSEIF n = 200 THEN
      ;special OOB to exit base
      EXIT
    FI
  OD

  NPutC(155)
RETURN


